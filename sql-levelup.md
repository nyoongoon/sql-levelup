# 구성

## 1장 : DBMS 아키텍처

- RDB의 내부 동작 모델 이해
- 데이터 캐시 또는 워킹 메모리등의 메모리 관련 구조, 저장소 구조.
- SQL 퍼포먼스 이해하기 위한 핵심 개념인 실행 계획과, 실행계획을 만드는 옵티마이저

## 2장 : SQL 기초

- SQL기초 구문

## 3장 : SQL의 조건 분기

- case식을 사용했을 때 어떻게 성능이 변화하는지 실행 계획등을 통해 알아보기

## 4장 : 집약과 자르기

- SQL 집합 지향이라는 패러다임을 GROUP BY 구문과 집약 함수를 통해 살펴보기
- 이전 장에서 배운 CASE식을 활용해 집합 지향적인 SQL구문을 어떻게 만드는지, 성능변화도 알아보기.

## 5장 : 반복문

- RDB의 성능 문제를 발생시키는 원인 중 하나로 SQL이라는 집합 지향 세계에 절차지향적인 패러다임을 적용하려는 시도.
- 반복을 적용하는 것에 대한 문제

## 6장 : 결합

- SQL 성능 문제는 대부분 결합과 관련된 부분에서 발행
- Nested Loops, Hash, SortMerge와 같은 결합 알고리즘의 실행 계획 살펴보고, RDB가 결합을 최적화하려면 어떻게 해야 하는지.

## 7장 : 서브쿼리

- 문제를 작게 분할하고 단계적으로 해결하는 서브쿼리의 접근법은 절차지향적 프로그래밍과 비슷
- 이러한 접근법에 의존하게 되었을 때 발생하는 성능문제

## 8장 : SQL의 순서

- 절차지향적인 기능을 받아들이는 변화. -> 윈도우 함수

## 9장 : 갱신과 데이터 모델

- 데이터 모델 자체를 바꾸는 것이 성능 개선의 가장 좋은 수단

## 10장 : 인덱스 사용

- 어떤 조건에서 인덱스가 유용한지
- 조건을 만들어내기위한 데이터 모델과 사용자 인터페이스 설계 알아보기

# 1장 DBMS 아키텍처

## 01강 DBMS 아키텍처 개요

- 여러 RDB는 결국 **관계 모델**이라는 수학적 이론을 바탕으로 함
- 일반적인 DBMS 아키텍처 개요
  ![img](img/IMG_2527.jpg)
- DBMS 내부에 다양한 처리를 하는 기능이 있음

### 1. 쿼리 평가 엔진

- 쿼리 평가 엔진은 입력받은 SQL문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정
- 이때 결정되는 계획을 **실행 계획**이라고 부름
- 이 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 **접근 메서드**라고 함
- 성능과 깊은 연관
- cf) 쿼리는 좁은의미로 SELECT구문, 큰 의미로 SQL 구문 전체 의미. 이 책에서 쿼리는 SELECT

### 2. 버퍼 매니저

- DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해둠
- 이 메모리 영역을 관리하는 것이 버퍼 매니저
- 디스크를 관리하는 디스크 용량 매니저와 함께 연동되어 작동
- 성능과 연관

### 3. 디스크 용량 매니저

- 어디에 어떻게 데이터를 저장할지 관리, 데이터의 읽고 쓰기를 제어

### 4. 트랜잭션 매니저와 락 매니저

- 각 요청 처리는 DBMS 내부에서 트랜잭션이라는 단위로 관리됨
- 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 트랜잭션 매니저와 락 매니저의 역할
- -> 여러 구문을 동시에 실행할 때 성능과 관련

### 5. 리커버리 매니저

- 절대 잃어버리면 안되는 데이터를 위해 정기적으로 백업, 문제 시 복구해야하는데
- -> 이러한 기능을 수행하는 것이 리커버리 매니저.

## 2강 DBMS와 버퍼

- 데이터를 버퍼에 어떠한 식으로 확보할 것인가 하는 부분에서 트레이드 오프

### 1. 공짜 밥은 존재할까?

- 많은 데이터를 영속적으로 저장하려하면 속도를 잃고
- 속도를 얻고자하면 많은 데이터를 영속적으로 저장하기 힘든 트레이드 오프가 발생

### 2. DBMS와 기억장치의 관계

- DBMS는 데이터 저장을 목적으로 하는 미들웨어
- DBMS가 사용하는 대표적인 기억장치는 하드디스크와, 메모리

#### 버퍼를 이용한 속도 향상

- DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 떄문
- -> 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도
- -> 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 데이터를 검색
- -> 디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능향상
- -> SQL구문의 실행시간 대부분을 저장소 I/O에 사용하기 떄문
- -> 이렇게 성능향상을 목적으로 데이터를 저장하는 메모리를 **버퍼** 또는 **캐시**라고 함
- -> **버퍼에 데이터를 어떻게, 어느 정도 기간동안 올릴지 관리**하는 것이 DBMS의 버퍼 매니저.

### 3. 메모리 위에 있는 두 개의 버퍼

- DBMS가 데이터를 유지하기 위해 사용하는 메모리 영역은 크게 다음과 같이 두 종류
- 데이터 캐시
- 로그 버퍼
- -> 위 메모리 영역은 사용자가 용도에 따라 크기를 변경하는 것이 가능

#### 데이터 캐시

- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용
- -> 실행한 SELECT 구문에서 선택하고 싶은 데이터가 데이터 캐시에 있다면
- -> 디스크에 접근하지 않고 처리가 수행됨.

#### 로그 버퍼

- 로그 버퍼는 갱신처리 (INSERT, DELETE, UPDATE, MERGE)와 관련 있음
- DBMS는 갱신과 관련된 SQL구문을 받으면 곧바로 저장소에 있는 데이터를 변경하지 않음
- -> 일단 로그 버퍼 위에 변경정보를 보내고, 이후 디스크에 변경을 수행
- -> COMMIT 때 로그버퍼로부터 디스크로 정보를 복사
- -> 이처럼 DB갱신처리는 SQL구문의 실행 시점과 저장소 갱신시점에 차이가 있는 비동기 처리임
- -> 저장소 변경이 끝날 때까지 기다리면 사용자는 장기간 대기
- -> 따라서 한 번 메모리에 갱신 정보를 받은 시점에서 사용자에게는 해당 SQL 구문이 끝났다라고 통지하고 내부적으로 처리 계속 수행.

### 4. 메모리의 성질이 초래하는 트레이드 오프

- 메모리의 단점들
- 휘발성
- -> 로그 버퍼 위에 존재하는 데이터가 사라져 버릴 수도 있음
- -> 따라서 DBMS는 커밋 시점에 반드시 갱신 정보를 로그파일(영속적 저장소에 존재)에 씀으로써,
- -> 장애가 발생해도 정합성을 유지할 수 있게 함.
- **커밋**이란 갱신처리를 "확정"하는 것.
- DBMS는 커밋된 데이터를 영속화 한다.
- -> 커밋때 반드시 디스크에 동기 접근이 일어남. -> 지연 발생 가능성

### 5. 시스템 특성에 따른 트레이드 오프

#### 데이터 캐시와 로그 버퍼의 크기

- -> 로그버퍼의 초깃값이 굉장히 작음
- -> 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문
- -> 갱신이 많은 시스템이라면 로그 버퍼의 크기를 늘려주는 튜닝 고려 가능

### 6. 추가적인 메모리 영역 '워킹 메모리'

#### 언제 사용될까?

- 위의 2개의 버퍼 이외에도, 일반적으로 메모리 영역을 하나 더 갖고 있음
- 워킹 메모리 : 정렬 또는 해시 관련 처리.
- 정렬 : order by 구, 집합 연산, 윈도우 함수 등의 기능 사용할 때
- 해시 : 테이블 등 결합에서 해시 결합 사용될 때
- -> 워킹 메모리는 sql에서 정렬 또느 해시가 필요한 때 사용되고 종료되면 해제되는 임시 영역.

#### 성능 이슈 주의

- 워킹 메모리가 다두려는 데이터양보다 부족해지는 경우가 생기면
- 대부분의 DBMS가 디스크 저장소를 사용하기 때문. -> 접근 속도가 느림

#### 부족하면 무슨일이 일어날까?

- 워킹 메모리는 여러개의 SQL 구문들이 공유해서 사용하므로,
- -> 부하검사 등을 실시하지 않으면 메모리 부족현상이 일어날 지 판별하기 힘듬.
- -> sql 구분 하나 있을 때 뿐만아니라, 여러개 있을 때도 주의해야하므로 컨트롤이 힘듬

## 3강 DBMS와 실행 계획

### 1. 권한 이양의 죄악

- 비절차적인 RDB는 절차(HOW)에 대한 일을 사용자가 아니라 시스템에 맡겼음
- -> 사용자가 하는 일은 대상(What)을 기술하는 것으로 축소 됨.
- -> How를 의식하지 않고 사용하므로 어려움이 있음 -> 내부 절차를 알아야하는 이유

### 2. 데이터에 접근하는 방법은 어떻게 결정할까?

- RDB에서 **데이터 접근 절차를 결정**하는 모듈은 **쿼리 평가 엔진**이라고 함.
- 쿼리 평가 엔진은 사용자로부터 입력받은 SQL구문을 처음 읽어들이는 모듈
- -> 쿼리 평가 모듈은 추가로 파서 또는 옵티마이저와 같은 여러개의 서브 모듈로 구성
  ![img](/img/img.png)

#### 파서 (parser)

- 파서의 역할은 파스(구문분석)하는 것.
- 사용자로부터 입력받은 SQL 문법이 올바른지 검사
- -> 또한 파서는, SQL 구문을 정형적인 형식으로 변환해줌. -> DBMS 내부 후속처리가 효율화됨

#### 옵티마이저(optimizer)

- 파서를 통과한 쿼리는 옵티마이저로 전송됨.
- -> **옵티마이저는 실행계획(데이터 접근법)을 최적화**함.
- 인덱스의 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등
- -> 조건을 고려해서 선택가능한 많은 실행계획을 작성하고 (플랜 생성)
- -> 이들의 비용을 연산하고 (비용 평가)
- -> 가장 낮은 비용을 가진 실행계획을 선택함.(플랜 평가)

#### 카탈로그 매니저

- 옵티마이저 실행계획을 세울 때 옵티마이저에게 중요 정보를 제공하는 것이 카탈로그 매니저
- -> **카탈로그란 DBMS 내부 정보를 모아 놓은 테이블**들로 테이블 또는 인덱스의 통계정보가 저장되어 있음
- -> 카탈로그 정보를 간단하게 '통계 정보'라고 부르기도 함.

#### 플랜 평가

- 옵티마이저가 SQL 구문에서 여러개의 실행 계획을 세운 뒤
- -> 그것을 받아 **최적의 실행 결과를 선택**하는 것이 플랜 평가.
- -> **실행 계획**은 DBMS가 곧바로 실행할 수 있는 코드가 아님
- -> 인간이 읽기 쉽게 만들어진 계획서.
- -> 성능이 좋지 않은 SQL 구문이 있을 때 실행 계획을 읽고, 수정방안 등을 고려 가능.
- -> 이렇게 하나의 실행 계획을 선택하면 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행함.

### 3. 옵티마이저와 통계 정보

- 카탈로그 매니저가 관리하는 통계정보에 대해서는 DB엔지니어가 항상 신경 써줘야함.
- 플랜 선택을 옵티마이저에게 맡기는 경우, 최적 플랜이 선택되지 않는 경우가 있음.
- -> 옵티마이저가 실패하는 패턴 중 하나는, 통계정보가 부족한 경우

#### 카탈로그에 포함되어 있는 통계정보

- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 필드의 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
- 필드 내부에 있는 NULL 수
- 인덱스 정보
- -> 이러한 정보를 활용함으로써 옵티마이저는 실행 계획을 만듬
- -> 문제가 생기는 경우는 이러한 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때
- -> 테이블에 데이터 변경이 있을 때 카탈로그 정보가 갱신되지 않으면,
- -> 옵티마이저는 오래된 정보로 실행계획을 세움.

### 4. 최적의 실행 계획이 작성되게 하려면

- 올바른 통계 정보가 모이는 것은 SQL 성능에 있어서 굉장히 중요한 문제.
- 수동갱신 뿐 아니라, 정기적, 자동 통계정보갱신 수행하기도 함.
- 통계정보 갱신은 테이블, 인덱스의 크기와 수에 따라서 몇십분에서 몇시간이 소요되기도 하는
- 비용이 굉장히 높은 작업.
- DBMS마다 통계정보갱신 명령어가 있음.

## 4강 실행 계획이 SQL 구문의 성능을 결정

- 통계정보가 최신이라도 SQL구문이 너무 복잡하면 옵티마이저가 최적의 접근 경로를 선택하지 못할 수도 있음

### 1. 실행계획 확인 방법

- SQL 구문의 지연이 발생했을 때 제일 먼저 실행 계획을 살펴보기
- 오라클 : set autotrace traceonly
- Oracle과 SQLServer는 실행 계획 확인 명령어 이후 대상 SQL 구문을 실행함.
- (확인 명령과 SQL 구문 사이 개행 들어가도 상솬겂음)

#### 기본적인 SQL구문의 실행계획 3가지

- 테이블 풀 스캔의 실행 계획
- 인덱스 스캔의 실행 계획
- 간단한 테이블 결합의 실행 계획

### 2. 테이블 풀 스캔의 실행 계획

- 레코드 전체 검색하는 단순한 SQL 구문의 실행계획 살펴보기

```sql
SELECT *
FROM Shops;
```

- **DBMS 실행 계획 출력 시 공통으로 나타나는 부분 3가지**
- -> 1 조작 대상 객체
- -> 2 객체에 대한 조작의 종류
- -> 3 조작 대상이 되는 레코드 수

#### 1 조작 대상 객체

- Name 필드에 Shops 테이블이 출력됨.
- -> 이부분은 테이블 이외에도 인덱스, 파티션, 시퀀스처럼 SQL 구문으로 조작할 수 있는 객체라면 무엇이라도 올 수 있음.

#### 2 객체에 대한 조작의 종류

- Operation 필드에 출력됨
- -> TABLE ACCESS FULL은 테이블의 데이터를 전부 읽어들인다는 의미.

##### cf) 실행 계획의 실행 비용과 실행 시간

- 실행 계획의 실행 비용(Cost)는 평가하기 어려운 항목임
- 절대 평가의 지표로 쓰는 것은 곤란.
- Time 필드도 추정시간이므로 절대 지표로 사용 불가
- 실제 구문의 실행 시간은 (DBMS_XPLAN.DISPLAY_CURSOR)
- 위 실행 결과 각각의 필드의 의미
- -> E-Rows : 추정되는 조작 레코드 수
- -> A-Rows : 실제 조작 레코드 수
- -> A-Time : 실제 실행 시간

#### 3 조작 대상이 되는 레코드 수

- Rows라는 항목에 출력 됨
- 결합 또는 집약이 포함되면 1개의 SQL 구문을 실행해도 여러개의 조작이 수행됨
- -> 얼마의 레코드가 처리되는지가 비용 파악의 중요한 지표
- **위 결과들은 카탈로그 매니저로부터 얻은 값**들임!
- 실제 구문을 실행한 시점의 테이블 레코드 수와 차이가 있을 수 있음.

### 3. 인덱스 스캔의 실행 계획

```sql
SELECT *
FROM Shops
WHERE shop_id = '00050';
-- 결과
SELECT STATEMENT TABLE ACCESS BY INDEX ROWID
        INDEX UNIQUE SCAN
```

#### 실행계획 분석

##### 1. 조작 대상이 되는 레코드 수

- 기본키가 '00050'인 점포를 지정했으므로 접근 대상은 반드시 레코드 하나 -> Rows 1

##### 2, 3. 접근 대상 객체와 조작

- 인덱스를 사용해 스캔을 수행

### 4. 간단한 테이블 결합의 실행 계획

- SQL에서 지연이 일어나는 경우는 대부분 결합과 관련된 것.
- 결합을 사용하면 실행계획이 상당히 복잡해지므로, 옵티마이저도 최적의 실행계획을 세우기가 어려움
- **결합시점의 실행계획 특성을 파악하는 것이 중요**

```sql
SELECT shop_name
FROM Shops S INNER JOINE Reservations R
ON S.shop_id = R.shop_id;
```

#### 결합 알고리즘 3가지

##### 1. Nested Loops

- 한쪽 테이블을 읽으면서 레코드하나마다 결합조건에 맞는 레코드를 다른 테이블에서 찾는 방식
- 절차지향형언어로 구현한다면, 이중 반복이므로 중첩반복이라는 이름이 붙은것

##### 2. Sort Merge

- 결합키(shop_id)로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합
- 결합 전에 전처리로 정렬을 수행하는데, 이때 작업용 메모리로 워킹 메모리를 사용

##### 3. Hash

- 결합키값을 해시값으로 매핑하는 방법
- -> 해시 테이블을 만들어야하므로 작업용 메모리 영역을 필요로 함.

#### 결합 실행 계획 살펴보기

```sql
SELECT STATEMENT
           NESTED LOOPS TABLE ACCESS FULL                | RESERVATIONS
            TABLE ACCESS BY INDEX ROWID  | SHOPS
                INDEX UNIQUE SCAN        | PK_SHOPS
```

- Opration 필드를 보면 NESTED LOOPS라고 나오므로 어떤 알고리즘 사용한지 알 수 있음
- 실행계획은 일반적으로 트리구조. 중첩단계가 깊을수록 먼저 실행.
- Nested Loop 보다도
- Seq Scan과 Index Scan의 단계가 깊으므로 결합 전에 테이블 접근이 먼저 수행.
- 같은 중첩 단계에서는 위에서 아래로 실행됨
- Reservation 테이블에 대한 접근이 위에 있으므로 Reservation에 접근 먼저 일어남

## 5강 실행 계획의 중요성

- 옵티마이저 결과가 좋지 않을 경우가 있음
- 인덱스를 사용하지 않거나, 테이블 결합 순서를 이상하게 적거나.
- -> 최후의 튜닝 수단으로 실행 계획 수동 변경할 수 있음.
- -> 힌트를 하용하면 옵티마이저에게 강제 명령.
- 일행 계획을 변경하려면 어떤 선택지가 있는지 알아야함.
- -> 그러나 그 전에 SQL 구문이 어떠한 접근경로(access path)로 데이터를 검색하는지 아는지가 먼저
- -> 어떤 테이블 설정이 효율적인지, 어떤 SQL 구문이 주어졌을 때 어떠한 실행계획이 나올지도 예측할 수 있어야함.

### cf) DBMS 캐시 알고리즘

- 불특정 다수의 사용자로부터 요구되는 데이터의 캐시 히트율을 올리고 싶을 때,
- 어떤 데이터를 캐시하는 것이 좋을지 기계적으로 풀기위한 알고리즘은 LRU(Least Recently Used)
- 참조 빈도가 가장 적은 것을 캐시에서 버리는 알고리즘

### cf) 다양한 캐시

- 데이터베이스에 메모리를 너무 많이 할당해버리면, 물리 메모리가 고갈되어 운영체제에서 스왑이 일어날 수도 있음.
- 데이터베이스에 메모리를 얼마나 할당할지 판단할 때는 어디까지나 물리 메모리의 범위ㅔ서 가능한 많이

# 2장 SQL 기초

- RDB는 데이터를 관계(relation)이라는 형식으로 저장함.
- -> 구현으로는 이를 테이블이라고 부름.

## 6강 SELECT 구문

- 검색. 다른 말로는 질의(query), 추츨(retrieve)

### 1. SELECT 구와 FROM 구

- SELECT구문은 SELECT구와 FROM구 두부분으로 나누어짐.
- FROM구는 반드시 입력해야하는 것은 아니지만, 테이블에서 검색하는 경우에는 반드시 입력.
- -> 'SELECT 1' 처럼 상수를 선택하는 경우 FROM 안씀.

### 2. WHERE 구

- 이떄의 WHERE는 ~라는 경우 를 나타내는 '관게부사'

#### WHERE 구는 거대한 벤다이어그램

![img](/img/img_1.png)

- WHERE 구는 벤다이어그램을 그리기 위한 도구.

#### IN으로 OR 조건 간단하게 작성

```sql
SELECT name, address
FROM Address
WHERE address IN ('서울시', '부산시', '인천시');
```

#### NULL - 아무것도 아니라는 것은 무엇일까?

- WHERE구로 조건을 지정할때, 초보자가 곤란해하는 부분이 NULL을 검색할 때
- -> NULL 레코드를 선택할 때는 IS NULL 이라는 특별한 키워드 사용
- -> NULL 이 아닌 레코드는 IS NOT NULL.
- --> **NULL은 데이터값이 아니므로**, 데이터값에 적용하는 연산자(=)를 적용할 수 없음!

```sql
SELECT name, phone_nbr
FROM Address
WHERE phone_nbr IS NULL;
```

#### SELECT 구문은 절차 지향형 언어의 함수

- SELECT 구문은 일종의 '읽기 전용'함수
- -> SELECT 구문의 입력과 출력 **자료형**은 무엇일까?
- -> 답은 **테이블(관계)**
- -> 입력과 출력도 모두 2차원 표.
- -> 이러한 성질 때문에 관계가 닫혀있다는 의미로 폐쇄성(closure property)라고 부름
- -> 뷰와 서브쿼리를 함께 이해할 때는 이러한 개념이 굉장이 중요 !
  ![](/img/img_2.png)

### 3. GROUP BY 구 -> 집계함수 사용 가능

- GROUP BY를 사용하면 데이터 선택 뿐만아니라,
- -> 합계 또는 평균등의 **집계 연산**을 SQL 구문으로 할 수 있음
- -> GROUP BY 구는 테이블을 홀케이크처럼 다룬다 개념
- -> 케이크를 자를 때의 **기준은 필드**
- -> **잘라진 조각은 그룹**이라고 부름. **그룹은 집계함수 사용**이 가능.
- COUNT, SUM, AVG, MAX, MIN
- 조각으로 자르고 싶지 않다면
- -> GROUP BY 구문에 키를 지정X

```SQL
SELECT COUNT(*)
FROM Address
GROUP BY (); -- 생략은 가능하나 원칙은 GROUP BY문이 있어야 집계함수 가능.
```

### 4. HAVING 구

- 결과 집합에 또다시 조건을 걸어 선택하는 기능
- **WHERE 구가 '레코드'에 조건을 지정**한다면, **HAVING구는 '집합'에 조건을 지정**하는 기능.

```SQL
SELECT address, COUNT(*)
FROM Address
GROUP BY address
HAVING COUNT(*) = 1;
```

### 5. ORDER BY 구

- ORDER BY구가 없는 SELECT문은 순서가 정해진 규칙이 없음
- 순서를 보장하려면 명시적으로 순서를 지정해야함.

### 6. 뷰와 서브쿼리

- SELECT 구문을 데이터베이스 안에 저장하는 것이 -> 뷰(View)
- 뷰는 데이터베이스 안에 저장한다는 점에 테이블과 공통점이 있지만
- 테이블과 달리 뷰는 내붑에 데이터를 보유하지 않음. -> SELECT구문을 저장한 것.

```sql
CREATE VIEW 뷰이름 (필드이름1, 필드이름2 ...) AS
SELECT
...
```

```sql
-- 주소별 사람수를 구하는 SELECT구문을 뷰로 저장

CREATE VIEW CountAddress (v_address, cnt)
AS
SELECT address, COUNT(*)
FROM Address
GROUP BY address;

-- 사용 예시
SELECT v_address, cnt
FROM CountAddress -- 테이블 대신 뷰를 FROM구에 지정
```

- 위처럼 뷰라는 것은 '테이블의 모습을 한 SELECT 구문'
- 실제로는 내부적으로 추가적인 SELECT 구문을 실행하는 중첩 구조

#### 익명 뷰 (== 서브쿼리)
```sql
-- 뷰의 실제 내부 코드
SELECT v_address, cnt
FROM (SELECT address AS v_address, COUNT(*) AS cnt
      FROM Address
      GROUP BY address) AS CountAddress;
```
- 위처럼 **FROM구에 직접 지정하는 SELECT구문을 서브쿼리**라고 부름.

#### 서브쿼리를 사용한 편리한 조건 지정 (매칭 사용)
- 서브쿼리를 사용할 때 중요한 것 
- -> **WHERE구의 조건에 서브쿼리를 사용**하는 방법. --> **매칭**
- 서로다른 테이블에 있는 공통된 데이터를 선택
- -> Address 테이블에서 Address2 테이블에 있는 사람을선택 -> 매칭
- -> 이런경우 IN 조건을 활용가능 -> **IN은 서브쿼리를 매개변수로 받을 수도 있음!**

```sql
SELECT name 
    FROM Address
WHERE name IN (SELECT name FROM Address2);
```
- -> SQL은 서브쿼리부터 순서대로 실행 
- -> 앞의 SELECT 구문은 서브쿼리를 상수로 전개구문이 바뀌는 것
```sql
SELECT name 
    FROM Address
    WHERE name IN ('인성', '민', '준서', '지연', '서준', '중진')
```
- -> 동적으로 상수 리스트 생성하여 데이터 수정되어도 하드코딩 필요 없음

## 7강 조건 분기, 집합 연산, 윈도우 함수, 갱신

### 1. SQL과 조건 분기 - CASE식
- SQL에도 조건 분기를 하는 방법이 있지만 사용방법이 다름
- SQL은 코드를 절차적으로 기술하는것이 아니므로 조건 분기를 '문장'단위로 하지 않기 떄문
- -> SQL의 조건 분기는 "식"으로 분기를 함. -> **CASE 식**
- CASE식은 단순 CASE식과 **검색 CASE식** 두 종류가 있음.
- -> 검색 CASE식은 단순 CASE식의 기능을 모두 포함하므로 검색 CASE만 기억해도 충분
```sql
CASE WHEN [평가식] THEN [식]
    WHEN [평가식] THEN [식]
    WHEN [평가식] THEN [식]
    생략
    ELSE [식]
END
``` 
####  CASE식의 작동
- switch 조건문과 거의 비슷
- **CASE문은 특정한 값(상수)를 리턴**하는 것이 차이점
- CASE식의 강력한 점은 **식**이라는 것
- -> 식을 적을 수 있는 곳이라면 어디든 적을 수 있음
- SELECT, WHERE, GROUP BY, HAVING, ORDER BY 구와 같은 곳 어디에나 적을 수 있음.

### 2. SQL의 집합 연산 - UNION & INTERSECT & EXCEPT
- WHERE 구를 설명할 때 벤다이어그램을 사용한 집한 연산으로 예를 들었지만
- -> 테이블을 사용해 **집합 연산**을 하는 기능 -> **UNION**

#### UNION으로 합집합 구하기
- 중복된 레코드는 제거됨!
- -> 중복 제외하고 싶지 않으면 'UNION ALL'
```sql
SELECT * 
    FROM Address
UNION
SELECT *
    FROM Address2;
```

#### INTERSECT로 교집합 구하기
```sql
SELECT * 
    FROM Address
INTERSECT 
SELECT *
    FROM Address2;
```
- -> 양쪽에 공통으로 존재하는 레코드(로우)출력
- -> 마찬가지로 중복은 제거된 것임.

#### EXCEPT로 차집합 구하기 (오라클은 MINUS)
```sql
SELECT * 
    FROM Address
EXCEPT 
SELECT *
    FROM Address2;
```
- EXCEPT는 UNION과 INTERSECT와는 다르게, 
- -> 작성할 때 테이블 순서에 따라 결과가 다름
- 1-5 와 5-1이 다른 것과 같은 이치. (교환법칙 성립하지 않음)

### 3. 윈도우 함수
- 윈도우 함수는 데이터를 가공하게 해준다는점에서도 중요하지만 성능과도 큰 관계가 있음
- **윈도우 함수의 특징**은 한마디로 **집약 기능이 없는 GROUP BY 구**
- -> **GROUP BY구는 자르기와 집약**이라는 두 개의 기능으로 구분됨
- -> **윈도우 함수는 자르기 기능만** 있는 것.
```sql
SELECT address, COUNT(*)
    FROM Address
    GROUP BY address;

-- 결과
address  | count 
----------------
서울시     | 3
인천시     | 2
부산시     | 1
```
- 위 GROUP BY는 필드로 테이블을 자르고, 잘라진 조각 개수만큼 레코드수를 더해 결과를 출력
- 윈도우 함수도 테이블을 자르는 것은 GROUP BY와 같음
- 윈도우 함수는 이를 **PARTITION BY** 라는 구로 수행함.
- -> **차이점은 자른 후에 집약하지 않으므로** 출력 결과의 레코드수가 입력되는 테이블의 레코드수와 같다는 것.
- 윈도우 함수의 기본적인 구문은 **집약 함수 뒤에 OVER구를 작성**하고
- -> **내부에 자를 키를 지정하는 PARTITION BY 또는 ORDER BY를 입력**하는 것.
- -> 작성하는 장소는 SELECT구라고만 생각해도 문제없음.
```sql
SELECT address,
       COUNT(*) OVER(PARTITION BY address)
    FROM Address;

-- 결과
-- 결과
address  | count 
----------------
서울시     | 3
서울시     | 3
서울시     | 3
----------------
인천시     | 2
인천시     | 2 
----------------
부산시     | 1
```
#### 윈도우 함수로 사용할 수 있는 함수
- COUNT, SUM 같은 일반 함수
- RANK, ROW_NUMBER 같은 윈도우 전용함수 (순서함수)

### 4. 트랜잭션과 갱신
- 갱신 작업은 삽입, 제거, 갱신의 세종류로 분류
- 의외에도 삽입과 갱신을 합친 머지(MERGE)가 있음
#### INSERT로 데이터 삽입
- RDB에서 데이터를 등록하는 단위는 **레코드(행)**
- 기본적인 등록단위는 하나의 레코드 씩(여러개의 레코드를 한개의 insert구문에 삽입하는 DBMS도 있음)
- -> 이때 사용하는것이 INSERT구문
- -> 문자 그대로 레코드를 삽입.
#### DELETE로 데이터 제거
- 데이터를 삭제할 때는 하나의 레코드 단위가 아니라, 한 번에 여러개의 레코드 단위로 처리
#### UPDATE로 데이터 갱신
```sql
-- UPDATE구문을 한 번 사용해서 갱신
UPDATE Address
    SET phone_nbr = '080-5848-XXXX',
        age = 20
    WHERE name = '빛나래';
```
#### 예제
- Address테이블에서 성별 별로 나이 순위(건너뛰기 있게) 매기는 SELECT구문을 생각
```sql
SELECT name, RANK() OVER (PARTITION BY sex ORDER BY age DESC) rnk_desc 
    FROEM Address;
```

# 3장 SQL의 조건 분기
- CASE식 의외에도 조건 분기에 사용할 수 있는 구문 -> UNION
- 하지만 굉장히 좋지 않은 SQL 구문..
- -> UNION은 조건 분기를 위해 만들어진 것이 아님!
- 많은 사람들이 어떻게 작동할지 쉽게 예측할 수 있다는 이유에서 UNION을 많이 사용함

## 8강 UNION을 사용한 쓸데없이 긴 표현
- UNION을 사용한 조건 분기는 좋지 않음
- WHERE구만 조금씩 다른 여러개의 SELECT구문을 합쳐, 복수의 조건이 일치하는 하나의 결과 집합을 얻고 싶을 때 사용
- -> 성능에서 굉장히 큰 단점 -> 내부적으로 여러개의 SELECT 구문을 실행하는 실행계획으로 해석됨
- -> 테이블 접근 횟수가 많아져서 I/O비용이 크게 늘어남.

### 1. UNION을 사용한 조건 분기와 관련된 간단한 예제
- ex) 2001년까지는 세금이 포함되지 않은 가격을, 2002년부터느 세금 포함 가격을 필드로 표시
```sql
-- UNION을 사용한 안좋은 예시
SELECT item_name, year, price_tax_ex AS price
    FROM Items
    WHERE year <= 2001
UNION ALL 
SELECT item_name, year, price_tax_in AS price
    FROM Items
    WHERE year >= 2002;
```
- 위의 예시는 조건이 배타적이므로 중복된 레코드가 발생되진 않음
- 정렬들의 처리를 하지 않아도 되므로 UNION ALL을 사용
- 쓸데없이 길다는 것이 첫 번째 문제 -> 거의 같은 쿼리 두번 실행.
- 두번째 문제는 성능

#### UNION을 사용했을 떄의 실행 계획 문제
- -> 실행계획을 살펴보면 위의 UNION쿼리는 Items 테이블에 2회 접근하고 있음
- -> 그때마다 TABLE ACCESS FULL이 발생하므로 읽는 비용도 테이블 크기에 따라 선형적으로 증가
- -> 데이터 캐시에 테이블의 데이터가 있으면 완화되겠지만, 테이블이 커지면 캐시 히트율도 낮아짐.

### 2. WHERE 구에서 조건 분기를 하는 사람은 초보자
- 조건분기를 WHERE로 하지말고 **SELECT구만으로 조건 분기**하기
```sql
SELECT item_name, year,
    CASE WHEN year <= 2001 THEN price_tax_ex
        WHEN year >= 2002 THEN price_tax_in END AS price
    FROM Items;
```
- 이 쿼리도 위의 UNION쿼리와 같은 결과를 출력함
- 하지만 성능적으로 이 쿼리가 훨씬 좋음. 

### 3. SELECT 구를 사용한 조건 분기의 실행 계획
- Items 테이블에 대한 접근이 1회로 줄어들어 성능이 2배 좋아진 것임
- 가독성 또한 좋아짐. 
- -> UNION을 사용한 분기는 SELECT 구문을 기본단위로 분기하고 있음
- -> **구문을 기본 단위로 사용하고 있다는 점에서 아직 절차 지향형의 발성을 못벗어남**
- -> 반면, **CASE식을 사용한 분기는 문자 그대로 '식'을 바탕으로하는 사고**

## 9강 집계와 조건 분기
- 집계를 수행하는 쿼리 작성 시 쓸데없이 길어지는 경우 많음
- 지역별로 남녀 인구를 기록하는 Population 테이블
### 1. 집계 대상으로 조건 분기
- 절차지향적 사고방식으로는 남성의 인구를 지역별로 구하고, 여성의 인구를 지역별로 구한 뒤
- 머지하는 방법을 생각할 것임.. (안좋은예)
```sql
-- UNION 
SELECT prefecture, SUM(pop_mem) AS pop_mem, SUM(pop_wom) AS pop_wom
    FROM( SELECT prefecture, pop AS pop_mem, null AS pop_wom
            FROM Population
          WHERE sex = '1'
          UNION
          SELECT prefecture, NULL AS pop_men, pop AS pop_wom
          FROM Population
          WHERE sex = '2') TMP
    GROUP BY prefecture;
```
- -> WHERE 구에서 sex 필드로 분기하고 결과를 UNION으로 머지한다는 절자지향적인 구성이 문제
- -> 테이블 풀스캔 2번 일어남. 

#### 집계의 조건 분기도 CASE식을 사용
- CASE식을 집약함수 내부에 포함시켜서 남성인구와 여성인구 필터를 만들기
```sql
SELECT prefecture,
       SUM(CASE WHEN sex = '1' THEN pop ELSE 0 END) AS pop_men,
       SUM(CASE WHEN sex = '2' THEN pop ELSE 0 END) AS pop_wom
   FROM Population
   GROUP BY prefecture;
```
#### CASE 식의 실행 계획
- 풀스캔 1번으로 줄음


### 2. 집약 결과로 조건 분기
- 집약에 조건 분기를 적용하는 또 하나의 패턴으로, 집약 결과에 조건 분기를 수행
- ex) 조건
- -> 소속된 팀이 1개라면 해당 직원은 팀의 이름을 그대로 출력
- -> 소속된 팀이 2개라면 해당 직원은 '2개를 겸무' 라는 문자열을 출력
- -> 소속된 팀이 3개 이상이라면 해당 직원은 '3개 이상을 겸무' 문자열 출력
#### UNION을 사용한 잘못된 조건 분기
- 조건분기가 레코드 값이 아닌, 집합의 레코드수에 적용됨
- -> 따라서 조건 분기가 WHERE(레코드의 조건) 구가 아니라 HAVING(집합의 조건) 구에 지정
- -> 하지만 UNION으로 머지하고 있는 이상, 구문레벨의 분기일 뿐 WHERE구 사용과 크게 다르지 않음.
```sql
SELECT emp_name,
       MAX(team) AS team
    FROM Employees
    GROUP BY emp_name
    HAVING COUNT(*) = 1
UNION 
SELECT emp_name,
       '2개를 겸무' AS team
    FROM Employees
    GROUP BY emp_name
    HAVING COUNT(*) = 2
UNION
SELECT emp_name
        '3개 이상을 겸무' AS team
    FROM Employees
    GROUP BY emp_name
    HAVING COUNT(*) >= 3;
```
#### UNION의 실행계획
- 테이블 풀스캔 3번

#### CASE 식을 사용한 조건 분기
```sql
SELECT emp_name,
       CASE WHEN COUNT(*) = 1 THEN MAX(team)
            WHEN COUNT(*) = 2 THEN '2개를 겸무'
            WHEN COUNT(*) >= 3 THEN '3개 이상을 겸무'
          END AS team
    FROM Employees
    GROUP BY emp_name;
```
#### CASE식을 사용한 조건 분기의 실행계힉
- -> 테이블 풀스캔 1번 
- -> GROUP BY 해시 연산도 3회에서 1회로 줄어드
- -> 집약결과(COUNT 함수의 리턴값)를 CASE 식의 입력으로 사용했기 때문
- -> **COUNT 또는 SUM과 같은 집약함수의 결과는 1개의 레코드로 압축됨**
- -> 다르게 말하면 **집약함수의 결과는 스칼라 값**(더이상 분할 불가능 값)이 되는 것
- -> 따라서 CASE식의 매개변수에 집약함수를 넣을수 있는 것임. 

## 10강 그래도 UNION이 필요한 경우

### 1. UNION을 사용할 수밖에 없는 경우

### 2. UNION을 사용하는 것이 성능적으로 더 좋은 경우

## 11강 절차 지향형과 선언형

### 1. 구문 기반과 식 기반

### 2. 선언형의 세계로 도약

# 4장 집약과 자르기

## 12강 집약

### 1. 여러 개의 레코드를 한 개의 레코드로 직얍

### 2. 합쳐서 하나

## 13강 자르기

### 1. 자르기와 파티션

### 2. PARTITION BY 구를 사용한 자르기

# 5장 반복문

## 14강 반복문 의존증

### 1. 내부적으로는 반복문 사용

## 15강 반복계의 공포

### 1. 반복계의 단점

### 2. 반복계를 빠르게 만드는 방법은 없을까?

### 3. 반복계의 장점

## 16강 SQL에서는 반복을 어떻게 표현할까?

### 1. 포인트는 CASE식과 윈도우 함수

### 2. 최대 반복 횟수가 정해진 경우

### 3. 반복 횟수가 정해지지 않은 경우

## 17강 바이어스의 공죄

# 6장 결합

## 18강 기능적 관점으로 구분하는 결합의 종류

### 1. 크로스 결합 - 모든 겹합의 모체

### 2. 내부 결합 - 왜 '내부'라는 말을 사용할까?

### 3. 외부 결합 - 왜 '외부'라는 말을 사용할까?

### 4. 외부 결합과 내부 결합의 차이

### 5. 자기 결합 - '자기'란 누구일까?

## 19강 결합 알고리즘과 성능

### 1. Nested Loops

### 2. Hash

### 3. Sort Merge

### 4. 의도하지 않은 크롯 결합

## 20강 결합이 느리다면

### 1. 상황에 따른 최적의 결합 알고리즘

### 2. 실행 계획 제어

### 3. 흔들리는 실행 계획

# 7장 서브쿼리

## 21강 서브쿼리가 일으키는 폐해

### 1. 서브쿼리의 문제점

### 2. 서브쿼리 의존증

### 3. 장기적 관점에서의 리스크 관리

### 4. 서브쿼리 의존증 - 응용편

### 5. 서브쿼리는 정말 나쁠까?

## 22강 서브쿼리 사용이 더 나은 경우

### 결합과 집약 순서

# 8장

## 23강 레코드에 순번 붙이기

### 1. 기본 키가 한 개의 필드인 경우

### 2. 기본 키가 여러 개의 필드로 구성되는 경우

### 3. 그룹마다 순번을 붙이는 경우

### 4. 순번과 갱신

## 24강 레코드에 순번 붙이기 응용

### 1. 중앙값 구하기

### 2. 순번을 사용한 테이블 분할

### 3. 테이블에 존재하는 시퀀스 구하기

## 25강 시퀀스 객체, IDENTITY 필드, 채번 테이블

### 1. 시퀀스 객체

### 2. IDENTITY 필드

### 3. 채번 테이블

# 9장 갱신과 데이터 모델

## 26강 갱신은 효율적으로

### 1. NULL 채우기

### 2. 반대로 NULL을 작성

## 27강 레코드에서 필드로의 갱신

### 1. 필드를 하나씩 갱신

### 2. 다중 필드 할당

### 3. NOT NULL 제약이 걸려있는 경우

## 28강 필드에서 레코드로 변경

## 29강 같은 테이블의 다른 레코드로 갱신

### 1. 상관 서브쿼리 사용

### 2. 윈도우 함수 사용

### 3. INSERT와 UPDATE 어떤 것이 좋을까?

## 30강 갱신이 초래하는 트레이드오프

### 1. SQL을 사용하는 방법

### 2. 모델 갱신을 사용하는 방법

## 31강 모델 갱신의 주의점

### 높아지는 갱신비용

### 갱신까지의 시간 랙 발생

### 모델 갱신비용 발생

## 32강 시야 협착 : 관련 문제

### 1. 다시 SQL을 사용한다면

### 2. 다시 모델 갱신을 사용한다면

## 33강 데이터 모델을 지배하는 자가 시스템을 지배한다

# 10장 인덱스 사용

## 인덱스와 B-tree

### 1. 만능형 : B-tree

### 2. 기타 인덱스

## 35강 인덱스를 잘 활용하려면

### 1. 카디널리티와 선택률

### 2. 인덱스를 사용하는 것이 좋은지 판단하려면

## 36강 인덱스로 성능 향상이 어려운 경우

### 1. 압축 조건이 존재하지 않음

### 2. 레코드를 제대로 압푹하지 못한느 경우

### 3. 인덱스를 사용하지 않는 검색 조건

## 37강 인덱스를 사용할 수 없는 경우 대처법

### 1. 외부 설정으로 처리 - 깊고 어두운 강 건너기

### 2. 외부 설정을 사용한 대처 방법의 주의점

### 3. 데이터 마트로 대처

### 4. 데이터 마트를 채택할 시 주의점

### 5. 인덱스 온리 스캔으로 대처

### 6. 인덱스 온리 스캔의 주의사항 
