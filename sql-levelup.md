# 구성
## 1장 : DBMS 아키텍처
- RDB의 내부 동작 모델 이해
- 데이터 캐시 또는 워킹 메모리등의 메모리 관련 구조, 저장소 구조.
- SQL 퍼포먼스 이해하기 위한 핵심 개념인 실행 계획과, 실행계획을 만드는 옵티마이저
## 2장 : SQL 기초
- SQL기초 구문
## 3장 : SQL의 조건 분기
- case식을 사용했을 때 어떻게 성능이 변화하는지 실행 계획등을 통해 알아보기
## 4장 : 집약과 자르기
- SQL 집합 지향이라는 패러다임을 GROUP BY 구문과 집약 함수를 통해 살펴보기
- 이전 장에서 배운 CASE식을 활용해 집합 지향적인 SQL구문을 어떻게 만드는지, 성능변화도 알아보기. 
## 5장 : 반복문 
- RDB의 성능 문제를 발생시키는 원인 중 하나로 SQL이라는 집합 지향 세계에 절차지향적인 패러다임을 적용하려는 시도.
- 반복을 적용하는 것에 대한 문제
## 6장 : 결합
- SQL 성능 문제는 대부분 결합과 관련된 부분에서 발행
- Nested Loops, Hash, SortMerge와 같은 결합 알고리즘의 실행 계획 살펴보고, RDB가 결합을 최적화하려면 어떻게 해야 하는지.
## 7장 : 서브쿼리
- 문제를 작게 분할하고 단계적으로 해결하는 서브쿼리의 접근법은 절차지향적 프로그래밍과 비슷
- 이러한 접근법에 의존하게 되었을 때 발생하는 성능문제
## 8장 : SQL의 순서
- 절차지향적인 기능을 받아들이는 변화. -> 윈도우 함수
## 9장 : 갱신과 데이터 모델
- 데이터 모델 자체를 바꾸는 것이 성능 개선의 가장 좋은 수단
## 10장 : 인덱스 사용
- 어떤 조건에서 인덱스가 유용한지
- 조건을 만들어내기위한 데이터 모델과 사용자 인터페이스 설계 알아보기

# 1장 DBMS 아키텍처

## 01강 DBMS 아키텍처 개요
- 여러 RDB는 결국 **관계 모델**이라는 수학적 이론을 바탕으로 함
- 일반적인 DBMS 아키텍처 개요
![img](img/IMG_2527.jpg)
- DBMS 내부에 다양한 처리를 하는 기능이 있음

### 1. 쿼리 평가 엔진
- 쿼리 평가 엔진은 입력받은 SQL문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정
- 이때 결정되는 계획을 **실행 계획**이라고 부름
- 이 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 **접근 메서드**라고 함
- 성능과 깊은 연관
- cf) 쿼리는 좁은의미로 SELECT구문, 큰 의미로 SQL 구문 전체 의미. 이 책에서 쿼리는 SELECT

### 2. 버퍼 매니저
- DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해둠
- 이 메모리 영역을 관리하는 것이 버퍼 매니저
- 디스크를 관리하는 디스크 용량 매니저와 함께 연동되어 작동
- 성능과 연관 

### 3. 디스크 용량 매니저
- 어디에 어떻게 데이터를 저장할지 관리, 데이터의 읽고 쓰기를 제어

### 4. 트랜잭션 매니저와 락 매니저
- 각 요청 처리는 DBMS 내부에서 트랜잭션이라는 단위로 관리됨
- 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 트랜잭션 매니저와 락 매니저의 역할
- -> 여러 구문을 동시에 실행할 때 성능과 관련

### 5. 리커버리 매니저
- 절대 잃어버리면 안되는 데이터를 위해 정기적으로 백업, 문제 시 복구해야하는데
- -> 이러한 기능을 수행하는 것이 리커버리 매니저.


## 2강 DBMS와 버퍼
- 데이터를 버퍼에 어떠한 식으로 확보할 것인가 하는 부분에서 트레이드 오프 

### 1. 공짜 밥은 존재할까?
- 많은 데이터를 영속적으로 저장하려하면 속도를 잃고
- 속도를 얻고자하면 많은 데이터를 영속적으로 저장하기 힘든 트레이드 오프가 발생

### 2. DBMS와 기억장치의 관계
- DBMS는 데이터 저장을 목적으로 하는 미들웨어
- DBMS가 사용하는 대표적인 기억장치는 하드디스크와, 메모리
#### 버퍼를 이용한 속도 향상
- DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 떄문
- -> 자주 접근하는 데이터를 메모리 위에 올려둔다면, 같은 SQL 구문을 실행한다고 해도
- -> 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 데이터를 검색
- -> 디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능향상 
- -> SQL구문의 실행시간 대부분을 저장소 I/O에 사용하기 떄문
- -> 이렇게 성능향상을 목적으로 데이터를 저장하는 메모리를 **버퍼** 또는 **캐시**라고 함
- -> **버퍼에 데이터를 어떻게, 어느 정도 기간동안 올릴지 관리**하는 것이 DBMS의 버퍼 매니저.

### 3. 메모리 위에 있는 두 개의 버퍼
- DBMS가 데이터를 유지하기 위해 사용하는 메모리 영역은 크게 다음과 같이 두 종류
- 데이터 캐시
- 로그 버퍼
- -> 위 메모리 영역은 사용자가 용도에 따라 크기를 변경하는 것이 가능
#### 데이터 캐시
- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용
- -> 실행한 SELECT 구문에서 선택하고 싶은 데이터가 데이터 캐시에 있다면
- -> 디스크에 접근하지 않고 처리가 수행됨.
#### 로그 버퍼
- 로그 버퍼는 갱신처리 (INSERT, DELETE, UPDATE, MERGE)와 관련 있음
- DBMS는 갱신과 관련된 SQL구문을 받으면 곧바로 저장소에 있는 데이터를 변경하지 않음
- -> 일단 로그 버퍼 위에 변경정보를 보내고, 이후 디스크에 변경을 수행
- -> COMMIT 때 로그버퍼로부터 디스크로 정보를 복사
- -> 이처럼 DB갱신처리는 SQL구문의 실행 시점과 저장소 갱신시점에 차이가 있는 비동기 처리임
- -> 저장소 변경이 끝날 때까지 기다리면 사용자는 장기간 대기
- -> 따라서 한 번 메모리에 갱신 정보를 받은 시점에서 사용자에게는 해당 SQL 구문이 끝났다라고 통지하고 내부적으로 처리 계속 수행.

### 4. 메모리의 성질이 초래하는 트레이드 오프
- 메모리의 단점들
- 휘발성
- -> 로그 버퍼 위에 존재하는 데이터가 사라져 버릴 수도 있음
- -> 따라서 DBMS는 커밋 시점에 반드시 갱신 정보를 로그파일(영속적 저장소에 존재)에 씀으로써,
- -> 장애가 발생해도 정합성을 유지할 수 있게 함.
- **커밋**이란 갱신처리를 "확정"하는 것. 
- DBMS는 커밋된 데이터를 영속화 한다. 
- -> 커밋때 반드시 디스크에 동기 접근이 일어남. -> 지연 발생 가능성

### 5. 시스템 특성에 따른 트레이드 오프
#### 데이터 캐시와 로그 버퍼의 크기
- -> 로그버퍼의 초깃값이 굉장히 작음
- -> 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문
- -> 갱신이 많은 시스템이라면 로그 버퍼의 크기를 늘려주는 튜닝 고려 가능

### 6. 추가적인 메모리 영역 '워킹 메모리'
#### 언제 사용될까?
- 위의 2개의 버퍼 이외에도, 일반적으로 메모리 영역을 하나 더 갖고 있음
- 워킹 메모리 : 정렬 또는 해시 관련 처리.
- 정렬 : order by 구, 집합 연산, 윈도우 함수 등의 기능 사용할 때
- 해시 : 테이블 등 결합에서 해시 결합 사용될 때
- -> 워킹 메모리는 sql에서 정렬 또느 해시가 필요한 때 사용되고 종료되면 해제되는 임시 영역.
#### 성능 이슈 주의
- 워킹 메모리가 다두려는 데이터양보다 부족해지는 경우가 생기면
- 대부분의 DBMS가 디스크 저장소를 사용하기 때문. -> 접근 속도가 느림
#### 부족하면 무슨일이 일어날까?
- 워킹 메모리는 여러개의 SQL 구문들이 공유해서 사용하므로, 
- -> 부하검사 등을 실시하지 않으면 메모리 부족현상이 일어날 지 판별하기 힘듬.
- -> sql 구분 하나 있을 때 뿐만아니라, 여러개 있을 때도 주의해야하므로 컨트롤이 힘듬

## 3강 DBMS와 실행 계획
### 1. 권한 이양의 죄악
- 비절차적인 RDB는 절차(HOW)에 대한 일을 사용자가 아니라 시스템에 맡겼음
- -> 사용자가 하는 일은 대상(What)을 기술하는 것으로 축소 됨.
- -> How를 의식하지 않고 사용하므로 어려움이 있음 -> 내부 절차를 알아야하는 이유

### 2. 데이터에 접근하는 방법은 어떻게 결정할까?
- RDB에서 **데이터 접근 절차를 결정**하는 모듈은 **쿼리 평가 엔진**이라고 함.
- 쿼리 평가 엔진은 사용자로부터 입력받은 SQL구문을 처음 읽어들이는 모듈
- -> 쿼리 평가 모듈은 추가로 파서 또는 옵티마이저와 같은 여러개의 서브 모듈로 구성
![img](/img/img.png)

#### 파서 (parser)
- 파서의 역할은 파스(구문분석)하는 것.
- 사용자로부터 입력받은 SQL 문법이 올바른지 검사
- -> 또한 파서는, SQL 구문을 정형적인 형식으로 변환해줌. -> DBMS 내부 후속처리가 효율화됨

#### 옵티마이저(optimizer)
- 파서를 통과한 쿼리는 옵티마이저로 전송됨.
- -> **옵티마이저는 실행계획(데이터 접근법)을 최적화**함.
- 인덱스의 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등
- -> 조건을 고려해서 선택가능한 많은 실행계획을 작성하고 (플랜 생성)
- -> 이들의 비용을 연산하고 (비용 평가)
- -> 가장 낮은 비용을 가진 실행계획을 선택함.(플랜 평가)

#### 카탈로그 매니저
- 옵티마이저 실행계획을 세울 때 옵티마이저에게 중요 정보를 제공하는 것이 카탈로그 매니저
- -> **카탈로그란 DBMS 내부 정보를 모아 놓은 테이블**들로 테이블 또는 인덱스의 통계정보가 저장되어 있음
- -> 카탈로그 정보를 간단하게 '통계 정보'라고 부르기도 함.

#### 플랜 평가
- 옵티마이저가 SQL 구문에서 여러개의 실행 계획을 세운 뒤 
- -> 그것을 받아 **최적의 실행 결과를 선택**하는 것이 플랜 평가.
- -> **실행 계획**은 DBMS가 곧바로 실행할 수 있는 코드가 아님
- -> 인간이 읽기 쉽게 만들어진 계획서. 
- -> 성능이 좋지 않은 SQL 구문이 있을 때 실행 계획을 읽고, 수정방안 등을 고려 가능.
- -> 이렇게 하나의 실행 계획을 선택하면 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행함.

### 3. 옵티마이저와 통계 정보
- 카탈로그 매니저가 관리하는 통계정보에 대해서는 DB엔지니어가 항상 신경 써줘야함.
- 플랜 선택을 옵티마이저에게 맡기는 경우, 최적 플랜이 선택되지 않는 경우가 있음. 
- -> 옵티마이저가 실패하는 패턴 중 하나는, 통계정보가 부족한 경우
#### 카탈로그에 포함되어 있는 통계정보
- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 필드의 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
- 필드 내부에 있는 NULL 수
- 인덱스 정보
- -> 이러한 정보를 활용함으로써 옵티마이저는 실행 계획을 만듬
- -> 문제가 생기는 경우는 이러한 카탈로그 정보가 테이블 또는 인덱스의 실제와 일치하지 않을 때
- -> 테이블에 데이터 변경이 있을 때 카탈로그 정보가 갱신되지 않으면, 
- -> 옵티마이저는 오래된 정보로 실행계획을 세움.

### 4. 최적의 실행 계획이 작성되게 하려면
- 올바른 통계 정보가 모이는 것은 SQL 성능에 있어서 굉장히 중요한 문제.
- 수동갱신 뿐 아니라, 정기적, 자동 통계정보갱신 수행하기도 함.
- 통계정보 갱신은 테이블, 인덱스의 크기와 수에 따라서 몇십분에서 몇시간이 소요되기도 하는
- 비용이 굉장히 높은 작업. 
- DBMS마다 통계정보갱신 명령어가 있음. 

## 4강 실행 계획이 SQL 구문의 성능을 결정
- 통계정보가 최신이라도 SQL구문이 너무 복잡하면 옵티마이저가 최적의 접근 경로를 선택하지 못할 수도 있음

### 1. 실행계획 확인 방법
- SQL 구문의 지연이 발생했을 때 제일 먼저 실행 계획을 살펴보기
- 오라클 : set autotrace traceonly
- Oracle과 SQLServer는 실행 계획 확인 명령어 이후 대상 SQL 구문을 실행함.
- (확인 명령과 SQL 구문 사이 개행 들어가도 상솬겂음)

#### 기본적인 SQL구문의 실행계획 3가지
- 테이블 풀 스캔의 실행 계획
- 인덱스 스캔의 실행 계획
- 간단한 테이블 결합의 실행 계획

### 2. 테이블 풀 스캔의 실행 계획
- 레코드 전체 검색하는 단순한 SQL 구문의 실행계획 살펴보기
```sql
SELECT *
    FROM Shops;
```
- **DBMS 실행 계획 출력 시 공통으로 나타나는 부분 3가지**
- -> 1 조작 대상 객체
- -> 2 객체에 대한 조작의 종류
- -> 3 조작 대상이 되는 레코드 수
#### 1 조작 대상 객체
- Name 필드에 Shops 테이블이 출력됨. 
- -> 이부분은 테이블 이외에도 인덱스, 파티션, 시퀀스처럼 SQL 구문으로 조작할 수 있는 객체라면 무엇이라도 올 수 있음.
#### 2 객체에 대한 조작의 종류
- Operation 필드에 출력됨
- -> TABLE ACCESS FULL은 테이블의 데이터를 전부 읽어들인다는 의미.

##### cf) 실행 계획의 실행 비용과 실행 시간
- 실행 계획의 실행 비용(Cost)는 평가하기 어려운 항목임
- 절대 평가의 지표로 쓰는 것은 곤란.
- Time 필드도 추정시간이므로 절대 지표로 사용 불가
- 실제 구문의 실행 시간은 (DBMS_XPLAN.DISPLAY_CURSOR)
- 위 실행 결과 각각의 필드의 의미
- -> E-Rows : 추정되는 조작 레코드 수
- -> A-Rows : 실제 조작 레코드 수
- -> A-Time : 실제 실행 시간

#### 3 조작 대상이 되는 레코드 수 
- Rows라는 항목에 출력 됨
- 결합 또는 집약이 포함되면 1개의 SQL 구문을 실행해도 여러개의 조작이 수행됨
- -> 얼마의 레코드가 처리되는지가 비용 파악의 중요한 지표
- **위 결과들은 카탈로그 매니저로부터 얻은 값**들임!
- 실제 구문을 실행한 시점의 테이블 레코드 수와 차이가 있을 수 있음. 

### 3. 인덱스 스캔의 실행 계획
```sql
SELECT * 
    FROM Shops
    WHERE shop_id = '00050';
-- 결과
SELECT STATEMENT
    TABLE ACCESS BY INDEX ROWID
        INDEX UNIQUE SCAN
```
#### 실행계획 분석
##### 1. 조작 대상이 되는 레코드 수
- 기본키가 '00050'인 점포를 지정했으므로 접근 대상은 반드시 레코드 하나 -> Rows 1
##### 2, 3. 접근 대상 객체와 조작
- 인덱스를 사용해 스캔을 수행

### 4. 간단한 테이블 결합의 실행 계획 
- SQL에서 지연이 일어나는 경우는 대부분 결합과 관련된 것.
- 결합을 사용하면 실행계획이 상당히 복잡해지므로, 옵티마이저도 최적의 실행계획을 세우기가 어려움
- **결합시점의 실행계획 특성을 파악하는 것이 중요**
```sql
SELECT shop_name
    FROM Shops S INNER JOINE Reservations R
    ON S.shop_id = R.shop_id;
```
#### 결합 알고리즘 3가지
##### 1. Nested Loops
- 한쪽 테이블을 읽으면서 레코드하나마다 결합조건에 맞는 레코드를 다른 테이블에서 찾는 방식
- 절차지향형언어로 구현한다면, 이중 반복이므로 중첩반복이라는 이름이 붙은것
##### 2. Sort Merge
- 결합키(shop_id)로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합
- 결합 전에 전처리로 정렬을 수행하는데, 이때 작업용 메모리로 워킹 메모리를 사용
##### 3. Hash
- 결합키값을 해시값으로 매핑하는 방법
- -> 해시 테이블을 만들어야하므로 작업용 메모리 영역을 필요로 함.
#### 결합 실행 계획 살펴보기
```sql
SELECT STATEMENT
    NESTED LOOPS
        TABLE ACCESS FULL                | RESERVATIONS
            TABLE ACCESS BY INDEX ROWID  | SHOPS
                INDEX UNIQUE SCAN        | PK_SHOPS
```
- Opration 필드를 보면 NESTED LOOPS라고 나오므로 어떤 알고리즘 사용한지 알 수 있음
- 실행계획은 일반적으로 트리구조. 중첩단계가 깊을수록 먼저 실행. 
- Nested Loop 보다도
- Seq Scan과 Index Scan의 단계가 깊으므로 결합 전에 테이블 접근이 먼저 수행.
- 같은 중첩 단계에서는 위에서 아래로 실행됨
- Reservation 테이블에 대한 접근이 위에 있으므로 Reservation에 접근 먼저 일어남

## 5강 실행 계획의 중요성


# 2장 SQL 기초

## 6강 SELECT 구문
### 1. SELECT 구와 FROM 구
### 2. WHERE 구
### 3. GROUP BY 구
### 4. HAVING 구
### 5. ORDER BY 구
### 6. 뷰와 서브쿼리

## 7강 조건 분기, 집합 연산, 윈도우 함수, 갱신
### 1. SQL과 조건 분기
### 2. SQL의 집합 연산
### 3. 윈도우 함수
### 4. 트랜잭션과 갱신


# 3장 SQL의 조건 분기

## 8강 UNION을 사용한 쓸데없이 긴 표현
### 1. UNION을 사용한 조건 분기와 관련된 간단한 예제
### 2. WHERE 구에서 조건 분기를 하는 사람은 초보자
### 3. SELECT 구를 사용한 조건 분기의 실행 계획

## 9강 집계와 조건 분기
### 1. 집계 대상으로 조건 분기
### 2. 집약 결과로 조건 분기

## 10강 그래도 UNION이 필요한 경우
### 1. UNION을 사용할 수밖에 없는 경우
### 2. UNION을 사용하는 것이 성능적으로 더 좋은 경우

## 11강 절차 지향형과 선언형
### 1. 구문 기반과 식 기반
### 2. 선언형의 세계로 도약


# 4장 집약과 자르기

## 12강 집약
### 1. 여러 개의 레코드를 한 개의 레코드로 직얍
### 2. 합쳐서 하나

## 13강 자르기
### 1. 자르기와 파티션
### 2. PARTITION BY 구를 사용한 자르기


# 5장 반복문

## 14강 반복문 의존증
### 1. 내부적으로는 반복문 사용

## 15강 반복계의 공포
### 1. 반복계의 단점
### 2. 반복계를 빠르게 만드는 방법은 없을까?
### 3. 반복계의 장점

## 16강 SQL에서는 반복을 어떻게 표현할까?
### 1. 포인트는 CASE식과 윈도우 함수
### 2. 최대 반복 횟수가 정해진 경우
### 3. 반복 횟수가 정해지지 않은 경우

## 17강 바이어스의 공죄


# 6장 결합

## 18강 기능적 관점으로 구분하는 결합의 종류
### 1. 크로스 결합 - 모든 겹합의 모체
### 2. 내부 결합 - 왜 '내부'라는 말을 사용할까?
### 3. 외부 결합 - 왜 '외부'라는 말을 사용할까?
### 4. 외부 결합과 내부 결합의 차이
### 5. 자기 결합 - '자기'란 누구일까?

## 19강 결합 알고리즘과 성능
### 1. Nested Loops
### 2. Hash
### 3. Sort Merge
### 4. 의도하지 않은 크롯 결합

## 20강 결합이 느리다면
### 1. 상황에 따른 최적의 결합 알고리즘
### 2. 실행 계획 제어
### 3. 흔들리는 실행 계획


# 7장 서브쿼리
## 21강 서브쿼리가 일으키는 폐해
### 1. 서브쿼리의 문제점
### 2. 서브쿼리 의존증
### 3. 장기적 관점에서의 리스크 관리
### 4. 서브쿼리 의존증 - 응용편
### 5. 서브쿼리는 정말 나쁠까?
## 22강 서브쿼리 사용이 더 나은 경우
### 결합과 집약 순서


# 8장
## 23강 레코드에 순번 붙이기
### 1. 기본 키가 한 개의 필드인 경우
### 2. 기본 키가 여러 개의 필드로 구성되는 경우
### 3. 그룹마다 순번을 붙이는 경우
### 4. 순번과 갱신
## 24강 레코드에 순번 붙이기 응용
### 1. 중앙값 구하기
### 2. 순번을 사용한 테이블 분할
### 3. 테이블에 존재하는 시퀀스 구하기
## 25강 시퀀스 객체, IDENTITY 필드, 채번 테이블
### 1. 시퀀스 객체
### 2. IDENTITY 필드
### 3. 채번 테이블

# 9장 갱신과 데이터 모델
## 26강 갱신은 효율적으로
### 1. NULL 채우기
### 2. 반대로 NULL을 작성
## 27강 레코드에서 필드로의 갱신
### 1. 필드를 하나씩 갱신
### 2. 다중 필드 할당
### 3. NOT NULL 제약이 걸려있는 경우
## 28강 필드에서 레코드로 변경
## 29강 같은 테이블의 다른 레코드로 갱신
### 1. 상관 서브쿼리 사용
### 2. 윈도우 함수 사용
### 3. INSERT와 UPDATE 어떤 것이 좋을까?
## 30강 갱신이 초래하는 트레이드오프
### 1. SQL을 사용하는 방법
### 2. 모델 갱신을 사용하는 방법
## 31강 모델 갱신의 주의점
### 높아지는 갱신비용
### 갱신까지의 시간 랙 발생
### 모델 갱신비용 발생
## 32강 시야 협착 : 관련 문제
### 1. 다시 SQL을 사용한다면
### 2. 다시 모델 갱신을 사용한다면
## 33강 데이터 모델을 지배하는 자가 시스템을 지배한다

# 10장 인덱스 사용
## 인덱스와 B-tree 
### 1. 만능형 : B-tree
### 2. 기타 인덱스
## 35강 인덱스를 잘 활용하려면
### 1. 카디널리티와 선택률
### 2. 인덱스를 사용하는 것이 좋은지 판단하려면
## 36강 인덱스로 성능 향상이 어려운 경우
### 1. 압축 조건이 존재하지 않음
### 2. 레코드를 제대로 압푹하지 못한느 경우
### 3. 인덱스를 사용하지 않는 검색 조건
## 37강 인덱스를 사용할 수 없는 경우 대처법
### 1. 외부 설정으로 처리 - 깊고 어두운 강 건너기
### 2. 외부 설정을 사용한 대처 방법의 주의점
### 3. 데이터 마트로 대처
### 4. 데이터 마트를 채택할 시 주의점
### 5. 인덱스 온리 스캔으로 대처
### 6. 인덱스 온리 스캔의 주의사항 
